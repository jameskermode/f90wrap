#!/usr/bin/env python

"""
  f90wrap: F90 to Python interface generator with derived type support

  Copyright James Kermode 2011-2018

  This file is part of f90wrap
  For the latest version see github.com/jameskermode/f90wrap

  f90wrap is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  f90wrap is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with f90wrap. If not, see <http://www.gnu.org/licenses/>.

  If you would like to license the source code under different terms,
  please contact James Kermode, james.kermode@gmail.com
"""

from __future__ import print_function

import sys
import os
import traceback
import copy
import logging
import pprint
import warnings

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

from f90wrap import __version__

from f90wrap import parser as fparse
from f90wrap import fortran
from f90wrap.sizeof_fortran_t import sizeof_fortran_t
from f90wrap import transform as tf

from f90wrap import f90wrapgen as fwrap
from f90wrap import pywrapgen as pywrap
from f90wrap import directc

logging.basicConfig(stream=sys.stdout)
logger = logging.getLogger('f90wrap')

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''

    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg

    def __str__(self):
        return self.msg

    def __unicode__(self):
        return self.msg


def main(argv=None):
    '''Parse and wrap Fortran 90 code, including derived types.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = 'f90wrap'
    program_version = "v%s" % __version__
    program_version_message = '%%(prog)s %s' % program_version
    # program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    program_shortdesc = 'f90wrap: F90 to Python interface generator with derived type support'
    program_license = '''%s

   Copyright James Kermode 2011-2017

   These portions of the source code are released under the GNU General
   Public License, version 2, http://www.gnu.org/copyleft/gpl.html

   If you would like to license the source code under different terms,
   please contact James Kermode, james.kermode@gmail.com

   When using this software, please cite the following reference:

   http://www.jrkermode.co.uk/f90wrap

USAGE
''' % program_shortdesc

    try:
        # Setup argument parser
        parser = ArgumentParser(description=program_license, formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", default=0,
                            help="set verbosity level [default: %(default)s]")
        parser.add_argument('-V', '--version', action='version', version=program_version_message)

        parser.add_argument("files", nargs="+", help="The files to include in the wrap")
        parser.add_argument('-p', '--prefix',
                            help="""Prefix to prepend to arguments and subroutines.""",
                            default='f90wrap_')
        parser.add_argument('-c', '--callback', nargs="*", default=[],
                            help="""Names of permitted callback routines.""")
        parser.add_argument('-C', '--constructors', nargs="*", default=['initialise_ptr', 'initialise', 'allocate'],
                            help="""Names of constructor routines.""")
        parser.add_argument('-D', '--destructors', nargs="*", default=['finalise', 'deallocate'],
                            help="""Names of destructor routines.""")
        parser.add_argument('-k', '--kind-map',
                            help="""File containting Python dictionary in f2py_f2cmap format""")
        parser.add_argument('-s', '--string-lengths',
                            help=""""File containing Python dictionary mapping string length names to values""")
        parser.add_argument('-S', '--default-string-length', default=1024, type=int,
                            help="""Default length of character strings""")
        parser.add_argument('-i', '--init-lines',
                            help="""File containing Python dictionary mapping type names to necessary initialisation code""")
        parser.add_argument('-I', '--init-file',
                            help="""Python source file containing code to be added to autogenerated __init__.py""")
        parser.add_argument('-A', '--argument-name-map',
                            help="""File containing Python dictionary to rename Fortran arguments""")
        parser.add_argument('--short-names',
                            help="""File containing Python dictionary mapping full type names to abbreviations""")
        parser.add_argument('--py-mod-names',
                            help="File containing Python dictionary mapping Fortran module names to Python ones")
        parser.add_argument('--class-names',
                            help="File containing Python dictionary mapping Fortran type names to Python classes")
        parser.add_argument('--joint-modules',
                            help="File containing Python dictionary mapping modules defining times to list of additional modules defining methods")
        parser.add_argument('-m', '--mod-name', default='mod',
                            help="Name of output extension module (without .so extension).")
        parser.add_argument('--f90-mod-name', default=None,
                            help="Full name of compiled extension module. Default is _MOD_NAME. Set to PACKAGE._MOD_NAME if extension will be included in a package")
        parser.add_argument('-M', '--move-methods', action='store_true',
                            help="Convert routines with derived type instance as first agument into class methods")
        parser.add_argument('--shorten-routine-names', action='store_true',
                            help="Remove type name prefix from routine names, e.g. cell_symmetrise() -> symmetrise()")
        parser.add_argument('-P', '--package', action='store_true',
                            help="Generate a Python package instead of a single module")
        parser.add_argument('-a', '--abort-func', default='f90wrap_abort',
                            help='Name of Fortran subroutine to invoke if a fatal error occurs')
        parser.add_argument('--auto-raise-error', type=str, default='',
                            help="Generate calls to abort subroutine in f90wrap fortran wrappers: 'err_num_variable,err_msg_variable'")
        parser.add_argument("--only", nargs="*", default=[], help="Subroutines to include in wrapper")
        parser.add_argument("--skip", nargs="*", default=[],
                            help="Subroutines to exclude modules and subroutines from wrapper")
        parser.add_argument("--skip-types", nargs="*", default=[], help="Subroutines to exclude types from wrapper")
        parser.add_argument("--force-public", nargs="*", default=[], help="Names which are forced to be make public")
        parser.add_argument('--default-to-inout', action='store_true', default=False,
                            help="Sets all arguments without intent to intent(inout)")
        parser.add_argument("--conf-file", help="Use Python configuration script to set options")
        parser.add_argument("--documentation-plugin", help="Use Python script for expanding the documentation of "
                                                           "functions and subroutines. All lines of the given tree "
                                                           "object are passed to it with a reference to its "
                                                           "documentation")
        parser.add_argument("--py-max-line-length", help="Maximum length of lines in python files written. Default: 80")
        parser.add_argument("--f90-max-line-length", help="Maximum length of lines in fortan files written. "
                                                          "Default: 120")
        parser.add_argument('--keep-single-interfaces', action='store_true', default=False,
                            help="Keep interfaces that contain a single procedure")
        parser.add_argument('--type-check', action='store_true', default=False,
                            help="Check for type/shape matching of Python argument with the wrapped Fortran subroutine")
        parser.add_argument('--relative', action='store_true', default=False,
                            help="Using relative import instead of package name in the package")
        parser.add_argument('--external-packages', nargs='+', default=[],
                            help="List of json files listing modules/types coming from external f90wrap")
        parser.add_argument('--dump-package', default="",
                            help="Output json file where to dump package description, can be reused in another package later via --external-packages option")
        parser.add_argument('--return-decoded', action='store_true', default=False,
                            help="Return decoded strings instead of raw bytes")
        parser.add_argument('--return-bool', action='store_true', default=False,
                            help="Python functions return bool (instead of integer) when associated Fortran type is a logical")
        parser.add_argument('--direct-c', action='store_true', default=False,
                            help="Generate direct-C extension instead of relying on f2py")
        parser.add_argument('--build', action='store_true', default=False,
                            help="Build extension module after generating wrappers")
        parser.add_argument('--clean-build', action='store_true', default=False,
                            help="Clean build artifacts before building")

        args = parser.parse_args()
        logging.debug("sys.argv parsed: %s", sys.argv)

        if args.build and not args.direct_c:
            args.direct_c = True

        log_levels = {
            0: logging.ERROR,
            1: logging.WARNING,
            2: logging.INFO,
            3: logging.DEBUG
        }

        logging.getLogger().setLevel(log_levels.get(min(args.verbose, max(log_levels.keys())), logging.INFO))

        # set defaults, to be overridden by command line args and config file
        kind_map = {}
        short_names = {}
        string_lengths = {}
        init_lines = {}
        py_mod_names = {}
        class_names = {}
        argument_name_map = {}
        # move_methods = []
        # shorten_routine_names = []
        only = None
        skip = None
        skip_types = None
        force_public = None
        joint_modules = {}
        remove_optional_arguments = []

        # bring command line arguments into global scope so we can override them
        globals().update(args.__dict__)
        callback = list(args.callback)
        logging.debug("CLI callbacks received: %s", callback)

        # read command line arguments
        if args.kind_map:
            kind_map = eval(open(args.kind_map).read())
        constructors = args.constructors
        destructors = args.destructors

        if args.short_names:
            short_names = eval(open(args.short_names).read())

        if args.string_lengths:
            string_lengths = eval(open(args.string_lengths).read())

        if args.init_lines:
            init_lines = eval(open(args.init_lines).read())

        if args.py_mod_names:
            py_mod_names = eval(open(args.py_mod_names).read())

        if args.class_names:
            class_names = eval(open(args.class_names).read())

        if args.argument_name_map:
            argument_name_map = eval(open(args.argument_name_map).read())

        if args.only:
            only = [o.lower() for o in args.only]

        if args.skip:
            skip = [s.lower() for s in args.skip]

        if args.skip_types:
            skip_types = [s.lower() for s in args.skip_types]

        if args.force_public:
            force_public = [s.lower() for s in args.force_public]

        if args.joint_modules:
            joint_modules = eval(open(args.joint_modules).read())

        # documentation plugin
        if args.documentation_plugin:
            logger.info(f"Using documentation plugin script {args.documentation_plugin}")
            doc_plugin_fname = args.documentation_plugin
        else:
            doc_plugin_fname = None

        # Line lengths for python files
        if args.py_max_line_length:
            py_max_line_length = int(args.py_max_line_length)
            logger.info(f"Using maximum line length in python files: {py_max_line_length}")
        else:
            # default set by preserving the previously hardcoded value from pywrapgen.py
            py_max_line_length = 80

        # Line lengths for fortran files
        if args.f90_max_line_length:
            f90_max_line_length = int(args.f90_max_line_length)
            logger.info(f"Using maximum line length in fortran files: {f90_max_line_length}")
        else:
            # default set by preserving the previously hardcoded value from f90wrapgen.py
            f90_max_line_length = 120

        auto_raise_error = args.auto_raise_error

        # finally, read config file, allowing it to override command line args
        if args.conf_file:
            logger.info(f"Executing config file {args.conf_file}")
            # fixme: this does not get the locals() and globals()
            exec(open(args.conf_file).read())

        logger.info('Kind map (also saved to .f2py_f2cmap)')
        logger.info(pprint.pformat(kind_map))
        f2py_f2cmap = open('.f2py_f2cmap', 'w')
        pprint.pprint(kind_map, f2py_f2cmap)
        f2py_f2cmap.close()

        logger.info('Constructors:')
        logger.info(pprint.pformat(constructors))

        logger.info('Destructors:')
        logger.info(pprint.pformat(destructors))

        logger.info('Short names for derived types:')
        logger.info(pprint.pformat(short_names))

        logger.info('String lengths:')
        logger.info(pprint.pformat(string_lengths))

        logger.info('Initialisation lines for derived types')
        logger.info(pprint.pformat(init_lines))

        logger.info('Python module name remapping')
        logger.info(pprint.pformat(py_mod_names))

        logger.info('Class names remapping')
        logger.info(pprint.pformat(class_names))

        logger.info('Argument name map:')
        logger.info(pprint.pformat(argument_name_map))

        fsize = sizeof_fortran_t()
        logger.info(f'Size of Fortran derived type pointers is {fsize} bytes.')

        # parse input Fortran source files
        logger.info(f'Parsing Fortran source files {args.files} ...')
        parse_tree = fparse.read_files(args.files, doc_plugin_filename=doc_plugin_fname)
        logger.info('done parsing source.')

        if args.dump_package:
            print('Dump json file %s ...' % args.dump_package)
            fparse.dump_package(parse_tree, args.mod_name, class_names, dump_package)

        # add modules/types coming from other f90wrap packages
        if args.external_packages:
            print('Adding external f90wrap packages...' % args.files)
            parse_tree = fparse.add_external_packages(parse_tree, class_names, args.external_packages)
            print()
        
        tree = copy.deepcopy(parse_tree)

        types = fortran.find_types(tree, skip_types)
        logger.info('Derived types detected in Fortran source files:')
        logger.info(pprint.pformat(types))

        for type_name, typ in types.items():
            if not type_name in class_names.keys():
                class_names[type_name] = typ.orig_name
        logger.info('Class name mapping:')
        logger.info(pprint.pformat(class_names))

        # Find all modules and subroutines the user wishes to keep
        # FIXME: this is messy, add more logic to it
        kept_subs = []
        kept_mods = set()
        if only:
            for mod, sub, arg in fortran.walk_procedures(tree):
                if sub.name in only:
                    kept_subs.extend([sub])
                    if mod is not None:
                        kept_mods.add(mod)
        elif skip:
            for mod, sub, arg in fortran.walk_procedures(tree):
                if sub.name not in skip:
                    kept_subs.extend([sub])
                    if mod is not None:
                        kept_mods.add(mod)

        if len(kept_subs) == 0 and only:
            warnings.warn("None of the supplied procedures were found")

        # Find (recursively) all used modules
        kept_mods = tf.find_referenced_modules(kept_mods, tree)

        modules_for_type = {}
        for type_name, typ in types.items():
            modules_for_type[typ.mod_name] = typ.mod_name
        modules_for_type.update(joint_modules)
        logger.info('Modules for each type:')
        logger.info(pprint.pformat(modules_for_type))

        def collect_shape_hints(tree):
            hints = {}
            for module in tree.modules:
                mod_name = module.name
                for proc in getattr(module, 'procedures', []):
                    type_name = getattr(proc, 'type_name', None)
                    proc_key = (mod_name, type_name, proc.name)
                    for arg in getattr(proc, 'arguments', []):
                        for attr in getattr(arg, 'attributes', []):
                            if attr.startswith('dimension('):
                                dims = [d.strip() for d in attr[len('dimension('):-1].split(',')]
                                hints[(proc_key, arg.name)] = dims
                    ret_val = getattr(proc, 'ret_val', None)
                    if ret_val is not None:
                        for attr in getattr(ret_val, 'attributes', []):
                            if attr.startswith('dimension('):
                                dims = [d.strip() for d in attr[len('dimension('):-1].split(',')]
                                hints[(proc_key, 'return')] = dims
            return hints

        tree = tf.transform_to_generic_wrapper(tree,
                                               types,
                                               callback,
                                               constructors,
                                               destructors,
                                               short_names,
                                               init_lines,
                                               kept_subs,
                                               kept_mods,
                                               argument_name_map,
                                               move_methods,
                                               shorten_routine_names,
                                               modules_for_type,
                                               remove_optional_arguments,
                                               force_public=force_public,
                                               keep_single_interfaces=keep_single_interfaces)

        shape_hints = collect_shape_hints(tree)

        py_tree = copy.deepcopy(tree)
        f90_tree = copy.deepcopy(tree)

        interop_info = None
        if args.direct_c:
            interop_info = directc.analyse_interop(f90_tree, kind_map)
            # In Direct-C mode, use Python module name for C extension
            if not ('f90_mod_name' in globals() and globals().get('f90_mod_name')):
                globals()['f90_mod_name'] = f"_{mod_name}"

        py_tree = tf.transform_to_py_wrapper(py_tree, types)

        f90_tree = tf.transform_to_f90_wrapper(f90_tree, types,
                                               callback,
                                               constructors,
                                               destructors,
                                               short_names,
                                               init_lines,
                                               string_lengths,
                                               default_string_length,
                                               sizeof_fortran_t=fsize,
                                               kind_map=kind_map)

        if args.direct_c and not auto_raise_error:
            auto_raise_error = "ierr,errmsg"

        pywrap.PythonWrapperGenerator(
            prefix,
            mod_name,
            types,
            f90_mod_name=f90_mod_name,
            make_package=args.package,
            kind_map=kind_map,
            init_file=args.init_file,
            py_mod_names=py_mod_names,
            class_names=class_names,
            max_length=py_max_line_length,
            auto_raise=auto_raise_error,
            type_check=args.type_check,
            relative=args.relative,
            return_decoded=return_decoded,
            return_bool=return_bool,
            namespace_types=bool(args.direct_c),
        ).visit(py_tree)
        fwrap.F90WrapperGenerator(
            prefix,
            fsize,
            string_lengths,
            abort_func,
            kind_map,
            types,
            default_to_inout,
            max_length=f90_max_line_length,
            default_string_length=default_string_length,
            auto_raise=auto_raise_error,
            direct_c_interop=interop_info,
            toplevel_basename=(mod_name if args.direct_c else "toplevel"),
        ).visit(f90_tree)

        if args.direct_c and interop_info:
            from f90wrap.directc_cgen import DirectCGenerator

            logging.info("Generating Direct-C extension modules...")
            logging.debug("Direct-C callbacks: %s", callback)

            error_num_arg = None
            error_msg_arg = None
            if auto_raise_error:
                parts = [part.strip() for part in auto_raise_error.split(',') if part.strip()]
                if len(parts) == 2:
                    error_num_arg, error_msg_arg = parts

            generator = DirectCGenerator(
                root=f90_tree,
                interop_info=interop_info,
                kind_map=kind_map,
                prefix=prefix,
                handle_size=fsize,
                error_num_arg=error_num_arg,
                error_msg_arg=error_msg_arg,
                callbacks=callback,
                shape_hints=shape_hints,
                py_module_name=mod_name
            )

            # Use Python module name for C extension (with _ prefix)
            extension_basename = f"_{mod_name}"

            # Collect all procedures for Direct-C code generation
            # Procedures can be in multiple places after transformation:
            # 1. module.procedures (module-level procedures)
            # 2. module.interfaces[].procedures (generic interface procedures)
            # 3. type.procedures (type-bound procedures)
            # 4. tree.procedures (top-level procedures)
            all_procs = []
            for module in f90_tree.modules:
                # Module-level procedures
                all_procs.extend(module.procedures)

                # Generic interface procedures (including module procedures wrapped in interfaces)
                for iface in getattr(module, 'interfaces', []):
                    all_procs.extend(getattr(iface, 'procedures', []))

                # Type-bound procedures
                for derived in getattr(module, 'types', []):
                    all_procs.extend(getattr(derived, 'procedures', []))

            # Top-level procedures
            all_procs.extend(getattr(f90_tree, 'procedures', []))

            c_code = generator.generate_module(extension_basename, procedures=all_procs)

            if c_code:
                c_filename = f"{extension_basename}.c"
                with open(c_filename, 'w') as c_file:
                    c_file.write(c_code)
                logging.info(f"Generated {c_filename}")
            else:
                logging.info("No Direct-C compatible procedures found.")

            logging.info("Direct-C generation complete. Compile C files with your toolchain.")

        if args.build:
            from f90wrap import build

            logging.info("Building extension module...")
            ret = build.build_extension(
                module_name=args.mod_name,
                source_files=args.files,
                package_mode=args.package,
                clean_first=args.clean_build,
                verbose=args.verbose > 0
            )

            if ret != 0:
                logging.error("Build failed")
                return ret

            logging.info("Build complete")
        return 0

    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0

    except Exception as e:
        traceback.print_exc()
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help\n")
        if 'args' in locals() and args.verbose:
            raise
        else:
            return 2


if __name__ == "__main__":
    sys.exit(main())
